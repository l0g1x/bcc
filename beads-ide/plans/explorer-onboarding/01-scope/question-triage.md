# Question Triage: explorer-onboarding

**Scope selected:** P0 + P1
**Questions in scope:** 120
**Auto-answerable:** 82
**Branch points for human:** 38

---

## Auto-Answerable Questions

| # | Question | Proposed Answer | Source |
|---|----------|-----------------|--------|
| 2 | How does the proposed onboarding pattern align with the existing command palette (Cmd+K) workflow? | Onboarding actions ("Open Folder", "New Project") must also be registered as command palette actions. The palette is already the global action dispatcher; adding these actions there is zero-cost and follows the existing `useDefaultActions` pattern in `__root.tsx`. | Codebase: `command-palette` already wires actions via `useDefaultActions`; VS Code registers all primary actions in the palette. |
| 3 | Should the onboarding welcome screen be a dedicated route (e.g., `/welcome`) or a conditional state of the landing page (`/`)? | Conditional state of `/`. The landing page (`routes/index.tsx`) is a simple component—adding a conditional check for "no root configured" avoids an extra route, a redirect, and router complexity. The onboarding state is transient UI, not a shareable URL. | Codebase: `routes/index.tsx` is currently a thin landing component; TanStack Router's file-based routing makes extra routes non-trivial to conditionally suppress. |
| 4 | How should toast notifications be used during onboarding vs. inline feedback? | Toasts for async results (folder scan complete, error scanning folder). Inline feedback for synchronous validation (empty path, invalid path). This matches the existing pattern where Sonner toasts are used for API results and inline styles for form validation. | Codebase: `errorStyle` in `formula-tree.tsx` is inline; Sonner is used in the root layout for API feedback. |
| 5 | Does the existing `react-resizable-panels` layout need modification to support the onboarding state? | No structural modification needed. The sidebar panel already handles collapsed/expanded states. The onboarding content simply replaces the `FormulaTree` as `sidebarContent` when no root is configured. `AppShell` receives content via props and is layout-agnostic. | Codebase: `app-shell.tsx` passes `sidebarContent` as a prop; no coupling to `FormulaTree` content. |
| 7 | How should the existing Tailwind theme tokens (sidebar colors, brand colors) be applied to new onboarding components? | Use the same tokens already in use: `#252526` sidebar background, `#3c3c3c` borders, `#cccccc` primary text, `#38bdf8` brand accent, `#1e1e1e` deep background. New components must not introduce new color literals; reference existing CSS custom properties or inline constants from the established palette. | Codebase: all existing components use these exact values; `app.css` defines `@theme` tokens. |
| 8 | Can keyboard-only users complete the entire onboarding flow without a mouse? | Yes, this is a requirement not a question. The app already implements a skip-to-main-content link, ARIA labels, and Enter/Space keyboard handlers throughout. Onboarding buttons and the folder picker trigger must be `<button>` elements with proper focus management. | Codebase: `__root.tsx` has skip link; `formula-tree.tsx` has keyboard handlers; accessibility is an explicit convention. |
| 9 | Can users who rely on browser zoom (up to 200%) still use the onboarding and tree effectively? | Yes, required. Use relative units (em/rem/%) not fixed px for font sizes and spacing in new components. The current codebase mixes both; onboarding is a clean surface to establish the better pattern. | Industry standard: WCAG 1.4.4 requires text resizable to 200% without loss of content/functionality. |
| 10 | What should the user see when they launch the app for the very first time with no project root detected? | A centered welcome panel inside the sidebar (replacing the empty formula tree) with two primary actions: "Open Folder" and "New Project". The main content area shows the existing landing page text. The backend's `resolveProjectRoot` falls back to `process.cwd()` when no `.beads` dir is found, so "no root detected" means no formulas returned and no `.beads` directory anchoring the project. | Codebase: `config.ts` returns `startDir` as fallback; `formula-tree.tsx` already has an `EmptyState` component for zero formulas. |
| 11 | Should the onboarding distinguish between "no project root found" and "project root found but no formulas exist"? | Yes. These are two distinct states with different remedies: "no root" means show the full onboarding welcome with Open Folder / New Project. "Root found, no formulas" means show the existing `EmptyState` with search path hints. The backend's `/api/formulas` response already includes `searchPaths`; a separate `/api/workspace` or extending the existing response can expose whether a `.beads` dir was found. | Codebase: `EmptyState` component already exists for the zero-formula case; `config.ts` has `projectRoot` that differs from `startDir` only when `.beads` is found. |
| 12 | How should the current working directory / project root be surfaced in the UI? | In the sidebar header, below or replacing the current "Explorer" label, as a truncated path (basename of root, full path on hover/tooltip). This is the VS Code Explorer pattern. | Industry: VS Code shows workspace root in the Explorer panel header. |
| 14 | How should the app handle the case where the backend is unreachable during onboarding? | Reuse the existing `OfflineBanner` component already rendered in `__root.tsx`. The onboarding buttons should be disabled with a tooltip ("Backend unavailable") when the connection state is disconnected. No new error pattern needed. | Codebase: `OfflineBanner` is already rendered unconditionally in `__root.tsx`; connection state tracking already exists. |
| 16 | How should the app behave when resizing the sidebar with the file tree -- should the tree truncate names, wrap, or scroll horizontally? | Truncate with `text-overflow: ellipsis` and `overflow: hidden`. This is standard IDE behavior (VS Code, JetBrains). A `title` attribute provides full name on hover. No horizontal scroll—it breaks sidebar navigation. | Industry: all major IDEs use truncation; horizontal scroll in a narrow sidebar is a serious UX failure. |
| 18 | Should tree nodes (folders) be expandable/collapsible, and should their state persist across sessions? | Yes, expandable/collapsible with localStorage persistence. The existing `AppShell` already persists panel sizes to localStorage with `STORAGE_KEY = 'beads-ide-panel-sizes'`. Tree expansion state should use a parallel key. Groups in `FormulaGroupSection` already track `expanded` state via `useState(true)`—lifting this to localStorage is a small change. | Codebase: localStorage persistence is already the pattern for UI state (`app-shell.tsx`); `FormulaGroupSection` already has expand/collapse logic. |
| 19 | How does the three-panel AppShell change for the onboarding state? | No structural change. The sidebar receives different content (onboarding panel vs formula tree) based on app state. `AppShell` is already content-agnostic via props. The main panel continues to render the route outlet. | Codebase: `app-shell.tsx` is a pure layout component; `sidebarContent` is a `ReactNode` prop. |
| 22 | How do we ensure the onboarding flow is not shown to returning users? | Persist the selected root folder path in localStorage. On mount, if a persisted root path exists and the backend confirms the path is valid, skip onboarding and load the tree directly. This is consistent with how panel sizes are already persisted. | Codebase: `app-shell.tsx` uses `localStorage.getItem('beads-ide-panel-sizes')`; the `useKeyboardTip` hook uses `localStorage` for the one-time tip; this pattern is established. |
| 23 | Should onboarding state persist across sessions and how? | Yes, via localStorage for the root path selection. A key like `beads-ide-workspace-root` stores the last selected path. On startup, the frontend reads this and sends it to the backend to validate/activate. If the path no longer exists, fall back to onboarding. | Codebase: localStorage is the established persistence layer for UI state; no server-side session management exists. |
| 25 | What visual treatment should distinguish the onboarding/welcome state from the normal working state? | The welcome state shows a centered card/panel inside the sidebar with call-to-action buttons using the brand color `#38bdf8`. The normal state shows the formula tree with the "Explorer" header. The main area is identical in both states. No full-page overlay or route change needed. | Codebase: the existing `EmptyState` in `formula-tree.tsx` already demonstrates the in-sidebar centered content pattern. |
| 26 | What should the empty sidebar look like when no folder is open (pre-onboarding state)? | Two buttons: "Open Folder" (primary, brand-colored) and "New Project" (secondary/ghost), centered vertically in the sidebar, with a one-line description "Open a folder containing .formula.toml files". This follows VS Code's empty Explorer state exactly. | Industry: VS Code empty Explorer shows "Open Folder" and "Clone Repository" buttons. |
| 27 | How should the "Open Folder" and "New Project" buttons be styled -- primary brand buttons, ghost buttons, or card-based actions? | "Open Folder" = primary brand button (background `#38bdf8`, dark text). "New Project" = ghost/outline button (border `#3c3c3c`, text `#cccccc`). Card-based actions are appropriate only if there are 3+ options with descriptions; two actions fit the button pattern. | Codebase: brand color `#38bdf8` is established; modal buttons in `unsaved-changes-modal` use this hierarchy pattern. |
| 30 | What does a returning user expect? | Returning users expect the app to remember their last workspace and open it immediately—no onboarding re-shown. This is universal IDE/editor behavior. localStorage persistence of the root path satisfies this. | Industry: universal expectation across VS Code, JetBrains, Sublime Text. |
| 31 | What does the user do right before they need to switch folders? | They finish with one project's formulas and want to open a different project. The trigger is in the sidebar header (a "change folder" action) or via the command palette. This implies a persistent "change workspace" affordance in the sidebar header, not buried in a menu. | Industry: VS Code has "Open Folder" as a top-level File menu item and in the Explorer header when a workspace is open. |
| 32 | What happens after the user selects a formula from the tree? | Navigation to `/formula/:name` route—exactly what the current `FormulaTree.navigateTo()` does via `window.history.pushState`. No change to this flow; the file tree triggers the same navigation. | Codebase: `formula-tree.tsx` line 413: `window.history.pushState({}, '', /formula/${encodeURIComponent(name)})`. |
| 33 | What happens after they select a root folder -- what do they expect to see immediately? | The folder picker closes, a loading skeleton appears in the sidebar while the backend scans the directory, then the formula tree populates. A toast confirms "Opened: [folder name]". If no formulas are found, the `EmptyState` with path hints shows. Total time should be <500ms for typical directories. | Industry: VS Code shows the file tree immediately after folder selection, with progressive loading. |
| 34 | What if the user accidentally dismisses the onboarding screen and doesn't know how to get back to it? | The "Open Folder" action is registered in the command palette (Cmd+K) and available as a toolbar action in the sidebar header at all times. There is no true "dismiss"—the onboarding buttons live in the sidebar persistently until a folder is opened. | Codebase: command palette is always accessible; the sidebar is always visible. |
| 35 | What is the user's emotional state on first launch? | Cautiously optimistic but evaluating. They want to see competence and clarity immediately. Empty states must be instructive, not just blank. The existing `EmptyState` already provides path hints—the welcome state must be equally clear. | Universal UX principle: first impressions are formed in <1 second. |
| 36 | What is the user's primary goal when they first open Beads IDE? | Open or create a formula file and start editing/running it. Everything in onboarding must serve this single goal—no unnecessary steps. | Context: this is a developer tool; users open developer tools to do work, not to configure the tool. |
| 37 | Will users expect "Open Folder" to also configure the backend's search paths? | Yes, this is the core architecture question—and the answer must be yes. Opening a folder should set the backend's project root (via `resolveProjectRoot`), which then derives formula search paths automatically. The user should not need to separately configure search paths. | Codebase: `config.ts` derives `formulaPaths` from `projectRoot`; the user-visible model must map to this derivation. |
| 38 | Will users expect "Open Folder" to work like VS Code's "Open Folder"? | Yes. Users will expect: OS native file picker, single folder selection, immediate tree population, persistent across sessions. Deviations from this pattern require explicit explanation. | Industry: "Open Folder" is a universal interaction pattern established by VS Code and adopted broadly. |
| 39 | Will users expect a "Recent Folders" list? | Yes, but it's a P1 feature. A short list (5 items) in the welcome panel below the two main buttons satisfies the expectation without complicating the MVP. | Industry: VS Code, JetBrains, Sublime all have recent folders; absence is noticed but not a blocker. |
| 40 | Will users expect drag-and-drop to open a folder? | Some will, but it is not a requirement for MVP. The native file picker via `<input webkitdirectory>` covers the primary path. Drag-and-drop can be deferred (it requires a `dragover`/`drop` handler on the app root). | Industry: VS Code supports drag-and-drop but it is a secondary affordance; primary is File > Open Folder. |
| 41 | Will users expect keyboard shortcuts for the onboarding actions? | Yes. "Open Folder" should be accessible via Cmd+O or a labeled shortcut in the command palette. The command palette already displays shortcuts. No new keyboard framework needed. | Industry: VS Code uses Cmd+O for Open; command palette entry with shortcut label is sufficient. |
| 42 | Will users expect right-click context menus on tree items? | Some will, but not required for MVP. The existing tree has no context menu; adding one later is non-breaking. For MVP, hover actions (if any) are sufficient. | Codebase: no context menu infrastructure exists; adding one is significant scope; defer to P2/P3. |
| 43 | Will users expect the opened folder to persist across browser sessions and page reloads? | Yes, absolutely. This is a fundamental expectation—confirmed by the cross-cutting theme on persistence. localStorage persistence is the answer. | Industry: universal expectation; VS Code persists workspace across restarts. |
| 44 | Will users expect the root folder path to be visible at all times? | Yes. The sidebar header should show the project root directory name (basename) at all times when a folder is open. Full path available on tooltip/hover. | Industry: VS Code shows workspace name in Explorer header; path in status bar. |
| 45 | Will users expect to be able to create new .formula.toml files from within the IDE? | Some will, but the backend already supports writing new formulas via `PUT /api/formulas/:name` (it creates in the first search path if not found). A "New Formula" button is a V1.1 feature; the MVP is open/browse existing formulas. | Codebase: `formulas.ts` PUT handler creates new files; the UI affordance can be deferred. |
| 46 | Will users expect to open multiple folders or a single workspace? | Single workspace is correct for MVP. Multi-root workspaces are a VS Code advanced feature that adds significant complexity. The current multi-search-path model (Gas Town + User + Project) already handles the use case of formulas from multiple locations. | Codebase: `config.ts` already has a multi-path model; the "Open Folder" sets one project root, and the derived search paths give multi-source browsing. |
| 47 | Will users expect to search/filter within the file tree? | Yes, eventually. Not MVP. The command palette (Cmd+K) already provides formula search as a workaround. A dedicated tree search input is P2. | Codebase: command palette already searches formulas; dedicated filter can be added incrementally. |
| 48 | Will users expect to see ALL files inside the opened folder, not just .formula.toml files? | No, not for this tool. Beads IDE is a formula-focused tool, not a general-purpose file manager. Showing only `.formula.toml` files (and directory structure for context) is the correct scope. Users who want a file manager use their OS or VS Code. | Context: this is a specialized tool; showing all files adds noise without value. |
| 51 | How does the proposed file tree interact with the existing formula fetch hook (`useFormulas`)? | The new tree will either extend or replace `useFormulas`. The hook currently fetches from `/api/formulas` which returns a flat list grouped by search path. A new hook `useWorkspaceTree` will fetch from a new `/api/tree` endpoint that returns a recursive directory structure. `useFormulas` is preserved for formula operations (cook/sling/pour) which need the formula list model. | Codebase: `use-formulas.ts` fetches `/api/formulas`; a parallel `use-workspace-tree.ts` for the recursive tree is the clean separation. |
| 52 | Can the existing `UnsavedChangesModal` pattern be reused for confirming project switches? | Yes. The `UnsavedChangesModal` already exists with focus trap, dark theme, and three-action pattern. Switching workspace when a formula has unsaved changes should trigger this modal with adapted copy ("Save before switching folders?" instead of "Save before navigating?"). | Codebase: `UnsavedChangesModal` is already used in `formula-tree.tsx` for navigation; the pattern is directly reusable. |
| 54 | Should error states in the file tree follow the same pattern as the existing `errorStyle` (red background, red text)? | Yes. The `errorStyle` in `formula-tree.tsx` (red text `#f48771`, red-tinted background `#3c1f1e`) is the established error pattern. All new error states in the tree must use this same style. | Codebase: `errorStyle` is defined and used in `formula-tree.tsx`; consistency requires reuse. |
| 57 | Should "New Project" create a `.beads/` directory and scaffolded files, or just set the working directory? | Create a `.beads/` directory structure. The backend's `resolveProjectRoot` anchors the project root on the presence of `.beads/`—so "New Project" must create this directory to make the root stick. It should also create `formulas/` as a scaffold. A new backend endpoint `POST /api/workspace/init` handles this. | Codebase: `config.ts` resolveProjectRoot walks up looking for `.beads` dir; without it, the root is unstable. |
| 58 | How should recently opened projects be tracked and presented? | localStorage key `beads-ide-recent-roots` stores an array of up to 5 path strings, most-recent first. Displayed as a compact list in the welcome panel. On click, each item triggers the same "open folder" flow. | Codebase: localStorage is the established persistence layer; no server-side session tracking exists. |
| 59 | Should the file tree show only `.formula.toml` files, or also show the surrounding directory structure for context? | Show the directory structure (folders and their nesting) but only surface `.formula.toml` files as leaf nodes. Folders without any formulas (at any depth) are still shown for navigation context, but in a muted/grey style. This matches how VS Code shows a project even when only certain file types are relevant. | Industry: directory context is important for navigation; hiding folders makes paths ambiguous. |
| 60 | How should "Gas Town formulas" vs "User formulas" vs "Project formulas" be explained to a new user? | Rename the labels: "Gas Town formulas" → "Shared (Gas Town)", "User formulas" → "Personal (~/.beads)", "Project formulas" → "This Project". Add a tooltip or info icon on each group header explaining the source path. The cross-cutting theme explicitly calls this out as a high-priority fix. | Codebase: labels are generated in `formulas.ts` `getSearchPathLabel()`; they are data, not hardcoded in components, so renaming is surgical. |
| 64 | What is the complete flow for a first-time user from app launch to editing their first formula? | Launch → see welcome panel in sidebar → click "Open Folder" → OS file picker opens → select folder → picker closes → sidebar shows loading skeleton → skeleton replaced by formula tree → user clicks a formula → `/formula/:name` route loads → editor shows. If no formulas found: tree shows EmptyState with path hints. Total steps: 3 user actions. | Derived from codebase flow and industry best practice. |
| 65 | Should "Open Folder" use the native OS file picker (via `<input type="file" webkitdirectory>`) or a custom in-app file browser? | Native OS file picker via `<input type="file" webkitdirectory>` for the browser-based app. The File System Access API (`showDirectoryPicker`) is preferred where available (Chrome/Edge) as it gives a proper directory handle. Fall back to `<input webkitdirectory>` for Firefox. The path string is sent to the backend. | Technical: browser security model; `showDirectoryPicker` is the modern standard; `webkitdirectory` is the fallback. |
| 66 | What happens when the user selects a folder that contains no `.formula.toml` files? | Show the existing `EmptyState` component with the list of search paths, plus an instructional note: "No formulas found in [folder]. Place .formula.toml files in `formulas/` or `.beads/formulas/`." The workspace root is still saved; the user is not kicked back to onboarding. | Codebase: `EmptyState` component already handles this case; augmenting its copy for the "root set but no formulas" case is minimal. |
| 67 | What keyboard shortcuts should be supported in the tree (arrow keys, Enter, Home/End, type-ahead)? | Standard ARIA tree widget keyboard pattern: Up/Down arrows to navigate, Right to expand, Left to collapse/go to parent, Enter to open, Home/End for first/last item. Type-ahead is P2. This is an accessibility requirement, not just a convenience. | Industry: ARIA Authoring Practices Guide tree widget pattern; W3C specification. |
| 68 | How should drag-and-drop work in the file tree (if at all)? | Not in MVP. Drag-and-drop for reordering or moving formulas across directories adds complexity and risk. The primary interaction is click/keyboard to open. Drag to open a folder from the OS is a separate interaction handled at the app root level (not in the tree). | Scope: defer to avoid complexity; primary interaction paths cover the use case. |
| 69 | What confirmation or feedback should the user see after selecting "Open Folder"? | A loading skeleton replaces the sidebar content immediately (optimistic feedback). A success toast "Opened: [folder name]" appears when the tree is populated. On error (invalid path, permission denied), an inline error message in the sidebar plus a toast. | Codebase: `LoadingSkeleton` component already exists in `formula-tree.tsx`; Sonner toasts are already in root layout. |
| 72 | Is the file tree navigable with arrow keys following the standard tree keyboard pattern? | Yes, required—same answer as Q67. The ARIA tree widget pattern (Up/Down/Left/Right/Enter/Home/End) is the standard and must be implemented. | Industry: WCAG 4.1.2, ARIA tree widget pattern. |
| 74 | Where does the "selected root folder" state live and who owns it? | A new React context `WorkspaceContext` owns the root folder path. It reads/writes localStorage on change and exposes `rootPath`, `setRootPath`, `isOnboarding` to consumers. This follows the existing Context pattern (`BeadSelectionProvider`, `FormulaSaveProvider`). | Codebase: `contexts/` directory already has multiple context providers following the same pattern; a `WorkspaceProvider` is the natural addition. |
| 75 | What happens to the existing search-path labels ("Gas Town formulas", "User formulas", "Project .beads")? | They are preserved as group headers in the tree, but renamed (see Q60). When a workspace root is set, a new "This Project" group header appears at the top showing formulas from the opened folder. The existing multi-path groups remain for Gas Town and User formulas. | Codebase: `getSearchPathLabel()` in `formulas.ts` generates these labels from path comparisons; renaming is a 4-line change. |
| 76 | Does the backend need to support multiple concurrent workspace roots? | No. Single active root for MVP. The `cachedConfig` in `config.ts` is a module-level singleton; it supports one root at a time. Multi-root is a deferred complexity. | Codebase: `config.ts` has a single `cachedConfig`; multi-root would require significant refactoring. |
| 77 | Can we reuse `react-resizable-panels` for the tree, or do we need a tree widget library? | No library needed. The existing `FormulaGroupSection` in `formula-tree.tsx` already implements a functional tree-group pattern. It needs to be extended with recursive nesting support for subdirectories, but the core architecture (expand/collapse, keyboard, selection) is already built. `react-resizable-panels` is for layout panels, not tree widgets. | Codebase: `formula-tree.tsx` already has the tree item building blocks; no new library justification. |
| 78 | How do we handle recursive directory scanning without blocking the backend event loop? | Use async `readdir` with `{ withFileTypes: true }` and walk recursively with `await`. For large trees, implement a depth limit (default 5 levels) and stream results. Hono is async-first. The current `readdirSync` in `formulas.ts` is synchronous and must be replaced for the recursive tree endpoint. | Codebase: `formulas.ts` uses `readdirSync` (sync); the new tree endpoint must use async `readdir` to avoid blocking; Node.js `fs/promises` is available. |
| 79 | What existing code in `formula-tree.tsx` can be salvaged? | `LoadingSkeleton`, `EmptyState`, `FolderIcon`, `FileCodeIcon`, `ChevronIcon`, all style constants, `FormulaGroupSection` structure (extend rather than replace), `UnsavedChangesModal` integration, keyboard handler pattern. The grouping logic (`groupFormulas`) is replaced by the recursive tree model. | Codebase: direct inspection of `formula-tree.tsx`—all visual/interaction primitives are reusable. |
| 80 | How do we implement the folder picker UI without native OS dialogs? | Use `window.showDirectoryPicker()` (File System Access API) where available, falling back to a hidden `<input type="file" webkitdirectory>` element that is programmatically clicked. The path string is extracted and sent to the backend. This is entirely frontend-side; no backend change needed for the picker itself. | Technical: browser API standard; no custom in-app file browser needed for MVP. |
| 81 | How does the dirty-state tracking change for a tree model? | No change to dirty-state tracking per se. The `useFormulaDirty` context tracks dirty state by formula name, not by tree path. The tree uses the same formula names, so dirty dots on formula leaf nodes work identically. Parent folder nodes show a dirty indicator if any descendant formula is dirty (aggregate check). | Codebase: `useFormulaDirty` context is name-keyed; formula names are stable identifiers; no refactoring needed. |
| 82 | What is the migration path for existing users who have the current sidebar layout? | On first load after the update, if localStorage has no `beads-ide-workspace-root` key, show onboarding. If the backend's `getConfig()` returns a non-empty `formulaPaths`, auto-detect and pre-populate the root from the backend's `projectRoot`—so existing users see their formulas immediately without re-doing onboarding. | Codebase: `config.ts` `getConfig()` returns `projectRoot`; a `/api/workspace` endpoint can expose this for the frontend to pre-populate. |
| 83 | Does introducing a "root folder" concept break the existing multi-search-path model? | No, if "Open Folder" sets the project root and the backend's `getFormulaSearchPaths` derives paths from it. The multi-search-path model is preserved underneath—the root folder becomes the anchor, and Gas Town / User paths remain as additional sources. The sidebar continues to show all groups. | Codebase: `config.ts` `getFormulaSearchPaths` derives multiple paths from one `projectRoot`; the model is additive, not exclusive. |
| 84 | How do we handle the case where the selected root folder is deleted or unmounted? | On the next tree refresh (or on startup if the path is persisted), the backend returns an error or empty results. The frontend detects this (error response from `/api/tree` or empty formulas with a "path not found" signal) and shows a non-blocking banner: "Workspace folder not found: [path]" with a "Choose new folder" CTA. Do not silently fall back to onboarding without explanation. | Industry: VS Code shows a "folder not found" notification; does not reset the workspace silently. |
| 85 | What changes are needed in the shared types package? | Add: `WorkspaceRoot { path: string; exists: boolean }`, extend `FormulaListResponse` or add `WorkspaceResponse { root: WorkspaceRoot; tree: TreeNode[] }`, add `TreeNode { name: string; path: string; type: 'file' | 'dir'; children?: TreeNode[] }`. Update `packages/shared/src/ide-types.ts`. | Codebase: `packages/shared/src/ide-types.ts` already has the formula types; tree types are additive. |
| 87 | How often should the tree refresh to pick up filesystem changes? | Manual refresh + on-window-focus refresh. No polling by default. The existing `useFormulas` hook refreshes on mount only; adding a `visibilitychange` listener to re-fetch when the tab becomes active is sufficient for MVP. File watching (chokidar) is P2. | Industry: VS Code uses file watching; for MVP, focus-based refresh is standard for web apps (e.g., GitHub web UI). |
| 88 | What is the cost of recursive `readdirSync` on large directories? | Blocking: 100-500ms for 10,000 entries (confirmed by the cross-cutting theme). Must use async `readdir` with a depth limit. For directories with >1,000 files, cap the recursive scan and show a "showing top N items" notice. | Technical: Node.js benchmark data; explicitly noted in cross-cutting theme #3. |
| 89 | Should we cache the tree structure and serve diffs? | Not for MVP. A simple in-memory cache (invalidated on workspace root change) on the backend is sufficient. Full diff-based updates add complexity. Cache TTL of 5 seconds prevents redundant scans on rapid re-fetches. | Technical: over-engineering for MVP; simple cache invalidation is sufficient. |
| 90 | Will the "Open Folder" action block the UI while scanning? | No. The folder picker closes, a loading skeleton appears immediately (non-blocking), and the scan happens asynchronously. The skeleton is replaced when the response arrives. The scan itself is async on the backend (see Q78). | Codebase: `LoadingSkeleton` component already exists; async pattern is established. |
| 91 | What is the payload size for the tree API response? | For a typical project with 50 formulas in nested directories, the JSON payload is <50KB. For 1,000 formulas it's ~500KB—acceptable. For >10,000 files, pagination or lazy expansion is needed. MVP can set a hard limit of 500 tree nodes with a warning. | Technical: JSON serialization of directory trees; 500 nodes × ~100 bytes/node = ~50KB. |
| 92 | Do we need a new backend endpoint for recursive directory listing? | Yes: `GET /api/tree?root=[path]` returns a `TreeNode[]` recursive structure. This is separate from `/api/formulas` which returns the flat formula list. The tree endpoint drives the sidebar navigation; the formula endpoint drives operations. | Codebase: `/api/formulas` is flat; recursive tree requires a new endpoint. |
| 93 | Should we debounce tree expansion to prevent rapid API calls? | Not needed if tree expansion is client-side (expand/collapse is UI state, not an API call). If tree nodes lazy-load children, debounce at 150ms. For MVP with full tree loaded upfront, no debounce needed. | Technical: only relevant for lazy-load pattern which is out of MVP scope. |
| 94 | How does the tree interact with the existing formula fetch for cook/sling operations? | The tree is navigation only. When a formula is selected in the tree, it navigates to `/formula/:name`—the formula editor then uses `useFormulas` and `useFormulaContent` hooks to load the formula for operations. The tree does not need to know about cook/sling. Clean separation of concerns. | Codebase: `formula-tree.tsx` already only navigates on selection; the formula editor route handles all operations. |
| 96 | How do we test the tree component with deeply nested structures? | Vitest unit tests with mocked `TreeNode` fixtures at 3-5 levels of nesting. Playwright e2e tests that create a temporary directory structure with formula files. The existing test infrastructure (Vitest + Playwright) is sufficient. | Codebase: `Vitest` and `Playwright` are already in the stack. |
| 97 | What happens when the tree API contract changes? | Add `version` field to the tree response. The shared types package (`ide-types.ts`) is the contract boundary—both frontend and backend import from it. TypeScript will catch breaking changes at compile time across the monorepo. | Codebase: monorepo with shared types package; TypeScript compiler enforces the contract. |
| 98 | How do we prevent the sidebar from becoming a second monolith? | Decompose into: `WorkspaceHeader` (root path display + change button), `TreeView` (recursive tree rendering), `WelcomePanel` (onboarding), `EmptyState` (no formulas found). Each is a focused component. No single file should exceed ~200 lines. | Industry: component decomposition by responsibility; VS Code's Explorer is similarly decomposed. |
| 100 | How do we handle regressions in the existing formula operations? | The existing `useFormulas` hook and `FormulaTree` are not deleted—they are superseded by the new tree for navigation, but the formula operations (cook/sling/pour) continue to use the flat formula list from `/api/formulas`. The formula editor route is untouched. Regression tests focus on the formula operation paths. | Codebase: formula operations are in separate route components; tree change is sidebar-only. |
| 101 | What is the strategy for styling the new tree consistently? | Reuse the existing style constants from `formula-tree.tsx` as the starting point. Define new constants in the same pattern (CSSProperties objects). Do not introduce CSS modules or styled-components. Tailwind utility classes acceptable for new components. | Codebase: existing convention is inline CSSProperties + Tailwind utilities; maintain this. |
| 102 | How do we version the workspace configuration for backward compatibility? | Version field in localStorage: `{ version: 1, rootPath: "...", recentRoots: [...] }`. On load, if version is missing or mismatched, clear and re-onboard. Simple and robust for a localStorage-based config. | Technical: localStorage versioning is standard practice for persisted UI config. |
| 103 | Should the tree show only `.formula.toml` files or all files? | Show directory structure + only `.formula.toml` files as leaves. Same answer as Q48 and Q59. | See Q48, Q59. |
| 104 | How do we handle cross-platform path handling? | Use Node.js `path` module (already used in `config.ts` via `resolve`, `join`, `dirname`, `basename`). Frontend receives paths from backend and treats them as opaque strings for display. Path normalization happens on the backend only. | Codebase: `config.ts` already uses `node:path`; all path operations are backend-side. |
| 105 | How do we monitor for performance regressions in the tree? | Add a `performance.now()` timing log for the `/api/tree` response in development mode. Playwright e2e tests can assert that the tree renders within 500ms for a fixture with 100 formula files. | Industry: lightweight timing + e2e assertion is sufficient for MVP monitoring. |
| 108 | What is the component decomposition for the new sidebar? | `Sidebar` (layout shell, unchanged) > `WorkspaceHeader` (root path, change button) > `TreeView` (tree rendering, recursive) > `FormulaNode` (leaf formula item) > `DirectoryNode` (folder item with children) > `WelcomePanel` (onboarding state) > `EmptyState` (no formulas state). | Codebase: follows existing component decomposition pattern in `components/layout/`. |
| 109 | How does the new tree integrate with TanStack Router navigation? | Same as the existing `FormulaTree`: use `window.history.pushState` + dispatch `popstate` event to notify TanStack Router. The existing pattern in `formula-tree.tsx` lines 412-414 is not ideal (it bypasses the router) but is established and working. A cleaner approach uses `router.navigate()` from `@tanstack/react-router`—this is a good refactor opportunity but not required. | Codebase: `formula-tree.tsx` lines 407-416 shows the existing navigation pattern. |
| 110 | Does the "New Project" action create files on disk, and where? | Yes: creates `.beads/` directory and `formulas/` directory at the selected path. Backend endpoint `POST /api/workspace/init` with `{ path: string }` body. Minimal scaffold only—no template files unless Q70 branch point decides otherwise. | Codebase: `config.ts` anchors on `.beads/` dir; must create it for the root to be recognized. |
| 113 | How should tree indentation levels be visualized (indent guides, nesting lines, padding only)? | Padding-only indentation (16px per level) for MVP. Indent guides (vertical lines connecting siblings) are a VS Code v2 refinement. Padding-only is clean, simple, and already established by the `paddingLeft: '12px'` on `groupItemsStyle` in `formula-tree.tsx`. | Codebase: `formula-tree.tsx` uses padding-only indentation; consistent to maintain this. |
| 114 | How should the dirty indicator (unsaved changes dot) work with file-tree nesting -- should parent folders also show a dirty indicator? | Yes, parent folders show an aggregated dirty indicator (same amber dot `#fbbf24`) if any descendant formula is dirty. This is the VS Code pattern and provides visual context without requiring folder expansion. Calculated by walking the tree on each dirty state change. | Industry: VS Code Explorer shows dirty indicators on parent folders. Codebase: `dirtyDotStyle` is already defined with amber color. |
| 115 | What hover, focus, and active states should tree items have? | Hover: `backgroundColor: '#2a2d2e'`. Focus (keyboard): 1px outline `#007acc` (blue, consistent with skip-to-main link style in `__root.tsx`). Active/selected: `backgroundColor: '#094771'`. These are exactly the states already defined in `formula-tree.tsx` (`itemHoverStyle`, `itemActiveStyle`). Focus outline must be visible—not suppressed. | Codebase: all three states are already defined in `formula-tree.tsx`; reuse exactly. |
| 116 | What context does the user bring from their previous action? | Developer context: they have just started the IDE for the first time (or after clearing state) and have a project directory in mind. The onboarding must not assume they know what "Gas Town" or ".beads" means. Plain language and a direct action path are required. | Context: this is a specialized tool with domain-specific terminology; new users are unfamiliar with it. |
| 117 | What happens for users who have disabled JavaScript or have slow connections? | JavaScript disabled: the app is entirely non-functional (React SPA)—no special handling needed; the app already requires JS. Slow connections: the loading skeleton provides feedback; no additional handling for onboarding specifically. | Technical: SPA inherently requires JS; skeleton loader is already implemented. |
| 118 | What happens if the backend server is not running when they first open the app? | The `OfflineBanner` (already in `__root.tsx`) displays. The onboarding "Open Folder" button is disabled. The banner already handles this state—no new code needed for onboarding specifically. | Codebase: `OfflineBanner` is already rendered unconditionally; connection state tracking is established. |
| 119 | What happens if the user opens a folder with zero .formula.toml files? | Same as Q66. Show `EmptyState` with path hints. The workspace root is saved. User is not blocked. | See Q66. |
| 120 | Will users assume the app is indexing or watching the folder for changes? | Some will. A subtle "Last updated: [time]" timestamp in the sidebar header and a manual refresh button (⟳ icon) manage this expectation without requiring real-time file watching. VS Code does watch, but polling/focus-refresh is acceptable for a web app. | Industry: explicit staleness indicator is better than silent auto-refresh for web apps. |

---

## Branch Points (Human Decision Required)

| # | Question | Why Human Needed |
|---|----------|------------------|
| 1 | How should the "New Project" / "Open Folder" actions be made discoverable beyond the welcome screen (menu bar, sidebar action, command palette)? | The app has no menu bar today. Adding one is significant scope. The question is whether the command palette alone is sufficient discoverability, or whether a persistent toolbar/header button is needed. Tradeoff: menu bar = more VS Code-like but more implementation; command palette only = simpler but less discoverable to new users. |
| 6 | Should the file tree component be built on top of the existing `FormulaTree` or be a new component? | Option A: Refactor `FormulaTree` in place (smaller diff, risk of regressions in existing formula operations). Option B: New `WorkspaceTree` component that coexists then replaces (safer, more code initially). Real tradeoff between risk tolerance and code cleanliness. |
| 13 | What is the correct information hierarchy for the sidebar: project root > subdirectories > formula files, or flat group-by-search-path as it is now? | Two valid UX models: (A) directory-first hierarchy showing actual folder structure (like VS Code Explorer) or (B) preserve the current search-path grouping (Gas Town / User / Project) as top-level categories with directory structure within each group. High impact on the tree architecture and the mental model for users. |
| 15 | Should there be an "Open Recent" list, and how many items should it hold? | Feature scope decision. 0 items = simpler MVP. 3-5 items = better UX but requires localStorage management. 10+ items = starts to look like a project manager. No clear "right" answer—depends on how many projects users typically switch between. |
| 17 | How should the user switch between projects / root folders after initial selection? | Option A: A clickable root path in the sidebar header that reopens the folder picker. Option B: A dedicated "Change Folder" button always visible in the sidebar header. Option C: Command palette only. These have meaningfully different discoverability and UI footprint. |
| 20 | Should the backend "Open Folder" / root-change be a restart or a hot-reload? | Option A: Server restart (simplest—clears all state, `cachedConfig` reset, guaranteed clean state). Option B: Hot-reload via `clearConfigCache()` + re-init (no service interruption, more complex, risk of stale state). The `clearConfigCache()` function already exists in `config.ts`, enabling hot-reload—but whether stale state is a real risk is unknown. User-facing tradeoff: restart = brief downtime; hot-reload = seamless but potentially buggy. |
| 21 | Should the tree be virtualized to handle large directories? | Option A: Virtualize from day one (react-virtual or similar)—extra dependency, more complex, handles scale. Option B: Hard limit (e.g., 500 nodes) with a warning—simpler, may frustrate users with large repos. Option C: Render all, optimize later—simplest now, may cause jank. Depends on expected workspace sizes (Q86). |
| 24 | How should the folder path be truncated or abbreviated in the sidebar header? | Option A: Show only basename (e.g., `my-project`). Option B: Show `~/path/to/my-project` abbreviated. Option C: Show full path. The sidebar header is narrow (~200px). A mix of basename + full path on hover is likely correct, but the exact format depends on how much the user values seeing the full path at a glance. |
| 28 | How should the sidebar collapse/expand toggle be redesigned? | The current toggle is a text `<` / `>` button—functional but not polished. Options: chevron icon (most IDE-like), tab handle, keyboard-only approach (remove visible toggle, use keyboard shortcut). This is a visual design decision with UX preferences the human should confirm. |
| 29 | What does a returning user expect when switching between folders? | Specifically: should switching folders navigate away from the currently open formula, close it, or keep it open but grayed out? VS Code keeps files open in tabs; this app has no tab system. The answer shapes the folder-switch interaction significantly. |
| 49 | Are we assuming all users read left-to-right? | The current app is LTR only. For RTL (Arabic, Hebrew) support: text direction, tree indentation, chevron direction, and icon placement all invert. This is a deliberate scope decision—not something to auto-answer. |
| 50 | Are we assuming all users speak English? | The app currently has no i18n. Adding i18n infrastructure is a large cross-cutting concern. The decision to scope it in or out must be explicit. |
| 53 | How should the sidebar header styling change to accommodate a project name and path? | The current header is minimal (text "Explorer" + collapse button). With a project name and path, options include: compact single-line with truncation, two-line display (name + path), a richer header card with folder icon. This is a visual design decision that affects the entire sidebar. |
| 55 | Can users with cognitive disabilities understand the "Gas Town" vs "User" formula distinction? | This is partly answerable (rename the labels—see Q60 answer) but the deeper question is whether the multi-source grouping model itself is cognitively tractable for new users, or whether the sidebar should hide these categories initially and only reveal them on demand. A human needs to decide the exposure model. |
| 56 | What should the title bar / window header communicate? | The app runs in a browser—the browser controls the title bar. The `<title>` element can be updated dynamically. Options: "Beads IDE", "Beads IDE - [project name]", "[formula name] - Beads IDE". This is a preference decision, not a technical constraint. |
| 61 | What metadata should be visible for each formula in the tree (name only, path, last modified, dirty state, error state, step count)? | Name + dirty indicator is the established minimum. Adding last-modified, step count, or error state makes the tree more informative but also more visually dense. The decision involves a density vs. clarity tradeoff that depends on how the tool is actually used. |
| 62 | Should the sidebar show a search/filter input for formulas, and where should it appear? | Search in the sidebar is a feature scope question. If yes: pinned at top (VS Code style) or inline (fuzzy filter). The command palette (Cmd+K) already provides formula search. Having both may be redundant or complementary. Human should decide whether the sidebar search is in MVP scope. |
| 63 | How should the "Open Folder" action relate to the backend's search path configuration? | The core architecture fork: (A) "Open Folder" replaces all search paths (project-centric model). (B) "Open Folder" adds a new project search path on top of existing Gas Town / User paths (additive model). (C) "Open Folder" sets the project root only, and the backend's multi-path logic derives everything else. Option C is what the codebase implies, but the UX of options A vs C is meaningfully different and must be confirmed. |
| 70 | Should the "New Project" flow include a formula template picker (blank formula, workflow template, multi-step template)? | Scope decision. A template picker adds meaningful value but also adds a second screen to the "New Project" flow. MVP can skip templates (blank only) but this is a product decision, not a technical one. |
| 71 | Is the dark-only theme a barrier for any users? | The app is dark-only with no light mode. This is a known limitation. The decision to add a light mode (or system preference detection) is a significant scope addition. Must be a deliberate product decision. |
| 73 | Is the user always at a desktop, or could they be on a tablet or narrow screen? | The current layout is optimized for desktop (1200px+). The three-panel layout collapses poorly on tablet. If tablet support is in scope, the sidebar must have a mobile-friendly mode (bottom sheet or full-screen overlay). This is a responsive design scope decision. |
| 86 | What is the expected file count for a typical workspace root? | This is a product context question—only the human knows the typical Gas Town workspace size. The answer determines whether virtualization (Q21) is necessary for MVP, what the depth limit should be, and what performance targets to set. |
| 95 | Can we preload the tree for commonly used workspace roots? | Feature decision: predictive preloading adds complexity for uncertain benefit. The tradeoff is implementation cost vs. perceived performance improvement for power users who switch between a known set of workspaces. Human should confirm whether this matters for the target users. |
| 99 | What documentation is needed for the "Open Folder" / workspace model? | Scope decision: inline tooltips only, a dedicated help page, or a README update. Depends on how much the workspace model differs from user expectations and whether there's a docs site. |
| 106 | What is the plan for feature flags or gradual rollout? | Product/engineering decision: release the new sidebar all-at-once vs. behind a feature flag that can be toggled per user. A flag adds development overhead but reduces risk. Human must decide the rollout strategy. |
| 107 | How does the "Open Folder" action reach the backend given browser security constraints? | Two valid approaches: (A) Frontend gets a path string from the OS picker and sends it to the backend via a new `POST /api/workspace/open { path }` endpoint. (B) Backend opens a native dialog (not possible for a browser-served app). For a locally-served app (Hono on localhost), option A is the only valid approach—but the question of whether to use File System Access API vs. `<input webkitdirectory>` for getting the path has real tradeoffs around browser compatibility that the human should confirm given the target environment. |
| 111 | Should the selected/active formula have a left-edge accent bar (VS Code style) or full-row highlight? | Pure visual design preference. Both are common; left-edge bar is more VS Code-native; full-row highlight (already implemented as `#094771`) is simpler. Human should confirm whether to change the existing selection style. |
| 112 | What should the loading state look like during folder scanning (skeleton, spinner, progress bar)? | The `LoadingSkeleton` component already exists and is the default answer, but a spinner or progress bar might be more appropriate if scanning can take >1 second. The right choice depends on expected scan duration (related to Q86). Human input on expected scan time shapes this decision. |

---

## Recommended Interview Order

Present branch points in this order for efficient flow. Earlier answers unblock or constrain later ones.

1. **Q63** — How should "Open Folder" relate to backend search paths? (additive vs. replace vs. derive)
   - This is the single biggest architectural decision. All tree behavior, the sidebar hierarchy, and the formula grouping model depend on it.

2. **Q13** — What is the information hierarchy: directory-first or group-by-search-path?
   - Directly follows from Q63. If "Open Folder" is purely additive, groups are preserved. If it sets the root, directory-first makes more sense. Determines the tree architecture.

3. **Q86** — What is the expected file count for a typical workspace root?
   - Unblocks Q21 (virtualization), Q112 (loading state), and sets performance targets.

4. **Q20** — Restart vs. hot-reload when workspace root changes?
   - Architectural decision affecting backend design. Must be settled before building the `POST /api/workspace/open` endpoint.

5. **Q21** — Should the tree be virtualized from day one?
   - Depends on Q86. Answer here determines whether to add a virtualization library.

6. **Q6** — Refactor `FormulaTree` in place vs. new `WorkspaceTree` component?
   - Determines the implementation strategy and risk profile. Should be decided before any code is written.

7. **Q17** — How should the user switch between projects after initial selection?
   - Determines the sidebar header design (Q53 is downstream of this). Must be settled before designing the header.

8. **Q53** — How should the sidebar header accommodate a project name and path?
   - Downstream of Q17 and Q13. Once the interaction model is clear, the header design follows.

9. **Q1** — How discoverable should "Open Folder" / "New Project" be beyond the welcome screen? (menu bar question)
   - Scope decision on adding a menu bar. Should be decided early to avoid designing without this affordance then adding it late.

10. **Q107** — How does "Open Folder" reach the backend given browser security constraints?
    - Specifically: File System Access API vs. `<input webkitdirectory>`. Depends on target browser environment—human knows this.

11. **Q70** — Should "New Project" include a template picker?
    - Scope decision for the new project flow. Settles whether the flow is one step or two.

12. **Q15** — Should there be an "Open Recent" list, and how many items?
    - Scope decision for the welcome panel. Small but shapes the welcome panel design.

13. **Q49 + Q50** — LTR-only assumption and English-only assumption?
    - Deliberate scope decisions on i18n and RTL. Should be explicit even if the answer is "out of scope."

14. **Q71** — Is dark-only theme a barrier? Light mode in scope?
    - Scope decision with significant implementation cost if yes.

15. **Q73** — Desktop only, or tablet/narrow screen support?
    - Responsive design scope decision. Shapes whether the sidebar needs a mobile mode.

16. **Q28** — How should the sidebar collapse/expand toggle be redesigned?
    - Visual design preference; lower stakes, can be decided late.

17. **Q111** — Left-edge accent bar vs. full-row highlight for selected formula?
    - Visual design preference; can be decided late.

18. **Q61** — What metadata is visible per formula in the tree?
    - Density vs. clarity tradeoff; can be decided after higher-order structure is settled.

19. **Q62** — Should the sidebar have a search/filter input?
    - Feature scope; decides whether to add a second search surface alongside the command palette.

20. **Q106** — Feature flags / gradual rollout plan?
    - Delivery strategy; can be decided last as it doesn't block design or implementation decisions.

21. **Q99** — What documentation is needed?
    - Delivery scope; decide last.

22. **Q95** — Preload tree for commonly used roots?
    - Performance optimization; decide last based on what users actually experience in practice.

23. **Q24** — How should the folder path be truncated in the sidebar header?
    - Visual detail; downstream of Q53 and Q17; decide last.

24. **Q29** — What does the user expect when switching folders (open formula behavior)?
    - UX preference with no tab system; can be decided once the folder-switch flow is otherwise settled.

25. **Q55** — Should the multi-source grouping model be hidden initially?
    - Downstream of Q13; decide after the hierarchy model is confirmed.

26. **Q56** — What should the browser title bar communicate?
    - Minor preference; decide last.
